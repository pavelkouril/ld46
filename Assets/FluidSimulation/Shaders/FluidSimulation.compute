#pragma kernel ResetTextures
#pragma kernel AddFluid
#pragma kernel ForceApplication
#pragma kernel ForcePropagation
#pragma kernel Advection
#pragma kernel Overflow
#pragma kernel Diffusion
#pragma kernel CheckFlowers

float _deltaTime;
int _FluidInputX;
int _FluidInputY;
int _FluidInputZ;

Texture3D<float> density;
RWTexture3D<float> densityRW;

Texture3D<float3> velocity;
RWTexture3D<float3> velocityRW;

//RWTexture3D<float3> rbVelocity;

Texture3D<float3> force;
RWTexture3D<float3> forceRW;

Texture3D<float> collision;

RWTexture3D<int> mlh;

RWStructuredBuffer<int> flowersWatered;
StructuredBuffer<int3> flowersPositions;
int _flowerCount;

#include "Functions.cginc"

[numthreads(8, 8, 8)]
void ResetTextures(uint3 threadId : SV_DispatchThreadID)
{
	densityRW[threadId] = 0;
	velocityRW[threadId] = float3(0, 0, 0);
	forceRW[threadId] = float3(0, 0, 0);
}

[numthreads(1, 1, 1)]
void AddFluid(uint3 threadId : SV_DispatchThreadID)
{
	int3 inputLoc = int3(_FluidInputX, _FluidInputY, _FluidInputZ);
	densityRW[inputLoc] = densityRW.Load(int4(inputLoc, 0)) + 1;
}

[numthreads(8, 8, 8)]
void ForceApplication(uint3 threadId : SV_DispatchThreadID)
{
	float rigidbodyDensity = collision.Load(uint4(threadId, 0));
	float fluidDensity = density.Load(uint4(threadId, 0));

	// voxel colliding with rigidbody?
	if (fluidDensity + rigidbodyDensity > 1 && rigidbodyDensity > 0)
	{
		// then the rb velocity becomes the collision force
		//forceRW[threadId] = normalize(rbVelocity.Load(uint4(threadId, 0)));
	}
	// voxel colliding only with other fluid
	else if (fluidDensity > 1)
	{
		forceRW[threadId] = force.Load(uint4(threadId, 0));
	}
	// if voxel is not overflown, it's not colliding with anything
	else
	{
		forceRW[threadId] = float3(0, 0, 0);
	}
}

[numthreads(8, 8, 8)]
// analogical to advection, but displaces based on forces from force application
void ForcePropagation(uint3 threadId : SV_DispatchThreadID)
{
	int a, b, c;

	float rigidbodyDensity = collision.Load(int4(threadId, 0));
	float fluidDensity = density.Load(int4(threadId, 0));

	float netInflow = 0;
	float3 netInflowWeightedVelocities = float3(0, 0, 0);
	float3 netInflowWeightedForces = float3(0, 0, 0);

	for (a = -1; a <= 1; a++)
	{
		for (b = -1; b <= 1; b++)
		{
			for (c = -1; c <= 1; c++)
			{
				float amount = inflowForce(threadId, int3(threadId.x + a, threadId.y + b, threadId.z + c));
				netInflow += amount;
				netInflowWeightedVelocities += velocity.Load(int4(threadId.x + a, threadId.y + b, threadId.z + c, 0)) * amount;
				netInflowWeightedForces += force.Load(int4(threadId.x + a, threadId.y + b, threadId.z + c, 0)) * amount;
			}
		}
	}

	float netBackflow = 0;
	for (a = -1; a <= 1; a++)
	{
		for (b = -1; b <= 1; b++)
		{
			for (c = -1; c <= 1; c++)
			{
				netBackflow += backflowForce(threadId, int3(threadId.x + a, threadId.y + b, threadId.z + c));
			}
		}
	}

	if (fluidDensity + rigidbodyDensity >= 1)
	{
		float localInflow = inflowForce(threadId, threadId);
		float totalAmount = netBackflow + localInflow;
		densityRW[threadId] = totalAmount;
		velocityRW[threadId] = totalAmount > 0 ? velocity.Load(int4(threadId, 0)) * localInflow / totalAmount : float3(0, 0, 0);
		forceRW[threadId] = totalAmount + rigidbodyDensity > 1 ? force.Load(int4(threadId, 0)) * localInflow / totalAmount : float3(0, 0, 0);
	}
	else
	{
		float totalAmount = netBackflow + netInflow;
		densityRW[threadId] = totalAmount;
		velocityRW[threadId] = totalAmount > 0 ? netInflowWeightedVelocities / totalAmount : float3(0, 0, 0);
		forceRW[threadId] = totalAmount + rigidbodyDensity > 1 ? netInflowWeightedForces / totalAmount : float3(0, 0, 0);
	}
}

[numthreads(8, 8, 8)]
// displace the fluid in one timestep based on their velocities
void Advection(uint3 threadId : SV_DispatchThreadID)
{
	int a, b, c;

	float rigidbodyDensity = collision.Load(uint4(threadId, 0));
	float fluidDensity = density.Load(uint4(threadId, 0));

	float netInflow = 0;
	float3 netInflowWeightedVelocities = float3(0, 0, 0);
	float3 netInflowWeightedForces = float3(0, 0, 0);

	for (a = -1; a <= 1; a++)
	{
		for (b = -1; b <= 1; b++)
		{
			for (c = -1; c <= 1; c++)
			{
				float amount = inflow(threadId, threadId + int3(a, b, c)); // compute how much fluid is received
				netInflow += amount;
				netInflowWeightedVelocities += velocity.Load(int4(threadId + int3(a, b, c), 0)) * amount;
				netInflowWeightedForces += force.Load(int4(threadId + int3(a, b, c), 0)) * amount;
			}
		}
	}

	float netBackflow = 0;
	for (a = -1; a <= 1; a++)
	{
		for (b = -1; b <= 1; b++)
		{
			for (c = -1; c <= 1; c++)
			{
				netBackflow += backflow(threadId, threadId + int3(a, b, c)); // compute how much fluid is returned due to locked voxels
			}
		}
	}

	float newDensity = 0;
	float3 newVelocity = float3(0, 0, 0);
	float3 newForce = float3(0, 0, 0);

	// determine the new densities, based if the voxel was overflown or not
	// the velocities and forces are displaced with densities, so they need to be recomputed as well
	if (fluidDensity + rigidbodyDensity >= 1)
	{
		float3 localVelocity = velocity.Load(int4(threadId, 0));
		float3 localForce = force.Load(int4(threadId, 0));
		float localInflow = inflow(threadId, threadId);

		newDensity = netBackflow + localInflow;
		newVelocity = newDensity > 0 ? (localInflow * localVelocity) / newDensity : float3(0, 0, 0);
		newForce = newDensity > 0 ? (localInflow * localForce) / newDensity : float3(0, 0, 0);
	}
	else
	{
		newDensity = netBackflow + netInflow;
		newVelocity = newDensity > 0 ? netInflowWeightedVelocities / newDensity : float3(0, 0, 0);
		newForce = newDensity > 0 ? netInflowWeightedForces / newDensity : float3(0, 0, 0);
	}

	densityRW[threadId] = newDensity;
	velocityRW[threadId] = newDensity > 0 ? newVelocity + float3(0, -9.81 * _deltaTime, 0) : float3(0, 0, 0);
	forceRW[threadId] = newForce;
}

[numthreads(8, 8, 8)]
void Overflow(uint3 threadId : SV_DispatchThreadID)
{
	float densityLocal = density.Load(int4(threadId, 0));
	float rigidbodyLocal = collision.Load(int4(threadId, 0));
	float densityDown = density.Load(int4(threadId + int3(0, -1, 0), 0));
	float rigidbodyDown = collision.Load(int4(threadId + int3(0, -1, 0), 0));
	float densityUp = density.Load(int4(threadId + int3(0, 1, 0), 0));
	float rigidbodyUp = collision.Load(int4(threadId + int3(0, 1, 0), 0));

	float newDensity = densityLocal;

	// transfer as much as possible not to be overflown
	if (densityLocal + rigidbodyLocal > 1 && rigidbodyUp < 1)
	{
		newDensity = clamp(1 - rigidbodyLocal, 0, densityLocal);
	}
	// receive fluid from bottom voxel
	if (densityDown + rigidbodyDown > 1 && rigidbodyLocal < 1)
	{
		newDensity += clamp(densityDown + rigidbodyDown - 1, 0, densityDown);
	}
	densityRW[threadId] = newDensity;
}

[numthreads(8, 8, 8)]
void Diffusion(uint3 threadId : SV_DispatchThreadID)
{
	// load all 3 voxels in this column
	float densityLocal = density.Load(int4(threadId, 0));
	float rigidbodyLocal = collision.Load(int4(threadId, 0));

	float allowedDiff = 0.0001;

	int a, c;

	float newDensity = densityLocal;

	for (a = -1; a <= 1; a++)
	{
		for (c = -1; c <= 1; c++)
		{
			if (a == 0 && c == 0)
			{
				continue;
			}

			// load the voxels in the other column
			float densityOther = density.Load(int4(threadId + int3(a, 0, c), 0));
			float rigidbodyOther = collision.Load(int4(threadId + int3(a, 0, c), 0));

			if (densityLocal + rigidbodyLocal > densityOther + rigidbodyOther - allowedDiff) // if the current voxel has more volume than its neighbouur
			{
				// transfer at most 1/8th of your volume
				newDensity -= clamp(densityLocal - (densityOther + rigidbodyOther), 0, densityLocal / 8);
			}

			if (densityLocal + rigidbodyLocal < densityOther + rigidbodyOther + allowedDiff) // if the current voxel has less volume than its neighbour
			{
				// recieve at most 1/8th of the neighbours volume
				newDensity += clamp(densityOther - (densityLocal + rigidbodyLocal), 0, densityOther / 8);
			}
		}
	}

	densityRW[threadId] = newDensity;
}


[numthreads(1, 1, 1)]
void CheckFlowers(uint3 threadId : SV_DispatchThreadID)
{
	for (int i = 0; i < _flowerCount; i++)
	{
		flowersWatered[i] = 0;
		for (int a = -1; a <= 1; a++)
		{
			for (int b = -1; b <= 1; b++)
			{
				for (int c = -1; c <= 1; c++)
				{
					if (density.Load(int4(flowersPositions[i] + int3(a, b, c), 0)) > 0)
					{
						flowersWatered[i] = 1;
					}
				}
			}
		}
	}
}